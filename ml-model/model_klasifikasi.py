# -*- coding: utf-8 -*-
"""model-klasifikasi-fixxx.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1opgQeG_n-vR3Q7_i6eXdSonAi0U4lv0v

### Import Library Dependencies
"""

import zipfile
import pandas as pd
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score
from sklearn import metrics
from sklearn import preprocessing
from sklearn.svm import SVC

# Import library Model
from sklearn.neighbors import KNeighborsClassifier

"""## Data Loading

Mendownload dataset berupa csv file melalui repository github

Dataset yang digunakan berupa informasi mengenai estimasi kelompok harga dari beberapa smartphone atau mobile devices berdasarkan spesifikasi yang dimiliki perangkat tersebut, seperti RAM, ROM, dan lainnya. Dataset diperoleh melalui proses scraping dari database mobile phone. Dataset:
[Mobile Price Classification](https://github.com/danielrymeds/dataset1/files/7698891/smartphone_specs.csv)

### Mendownload dan menyiapkan dataset
"""

!wget --no-check-certificate \
  https://github.com/danielrymeds/dataset1/files/7712532/mobile-price-classification.zip \

!wget --no-check-certificate \
  https://github.com/danielrymeds/dataset1/files/7712533/smartphone_specs.csv \

"""Mengekstrak zip file dari dataset mobile price"""

local_zip = '/content/mobile-price-classification.zip'
zip_ref = zipfile.ZipFile(local_zip, 'r')
zip_ref.extractall('/content')
zip_ref.close()

"""Mengubah dataset menjadi dataframe"""

df = pd.read_csv('/content/train.csv')
df.head()

"""## Data Understanding

Melihat informasi dataset secara keseluruhan dan juga secara statistik
"""

df.info()

df.describe()

"""Melihat missing values pada dataframe"""

df.isnull().sum()

"""Memeriksa rasionalitas beberapa variabel"""

px_h = (df.px_height==0).sum()
px_w = (df.px_width==0).sum()
sc_h = (df.sc_h==0).sum()
sc_w = (df.sc_w==0).sum()

print(px_h)
print(px_w)
print(sc_h)
print(sc_w)

"""Menghapus nilai yang tidak rasional pada variabel"""

df = df.loc[(df[['px_height','sc_w']]!=0).all(axis=1)]
df.shape

"""### Outliers

Melakukan drop outliers pada data
"""

Q1 = df.quantile(0.25)
Q3 = df.quantile(0.75)
IQR=Q3-Q1
df=df[~((df<(Q1-1.5*IQR))|(df>(Q3+1.5*IQR))).any(axis=1)]
 
# Cek ukuran dataset setelah outliers didrop
df.shape

"""### Visualisasi Data

Melakukan proses analisis data dengan teknik Univariate EDA
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

df.hist(bins=50, figsize=(20,15))
plt.show()

"""Membuat dataframe baru yang berisi beberapa kolom data dari dataframe awal, untuk nantinya digabungkan dengan data-data hasil scraping"""

df_new = pd.DataFrame()

df_new['Weight(g)'] = df['mobile_wt'].copy()
df_new['Width(px)'] = df['px_width'].copy()
df_new['Height(px)'] = df['px_height'].copy()
df_new['ROM(MB)'] = df['int_memory'].copy()
df_new['RAM(MB)'] = df['ram'].copy()
df_new['Battery Capacity(mAh)'] = df['battery_power'].copy()
df_new['Price'] = df['price_range'].copy()

df_new

"""### Pengolahan Dataset Scraping

Membuat dataframe tambahan dari file csv dataset hasil scraping
"""

df_add = pd.read_csv('/content/smartphone_specs.csv')
df_add

"""Mengolah Dataset hasil scraping"""

df_add = df_add.rename(columns={'Price(USD)': 'Price'})

df_add.isnull().sum()

df_add = df_add.dropna()

df_add.isnull().sum()

df_add.describe()

"""Mengambil data dengan nilai weight kurang dari 200g agar hanya termasuk data mobile phone dan bukan data ipad atau tab yang memiliki berat lebih dari 200g"""

df_add = df_add.loc[df_add['Weight(g)']<=200]

df_add

"""Membagi kolom price menjadi 4 kelas berdasarkan range harga berikut:

Price:


*   Range 0 = < 100 USD
*   Range 1 = 100 - 200 USD
*   Range 2 = 200 - 400 USD
*   Range 3 = >= 400 USD

"""

df_add.loc[df_add['Price']<100, 'Price'] = 0
df_add.loc[(df_add['Price']>=100) & (df_add['Price']<200), 'Price'] = 1
df_add.loc[(df_add['Price']>=200) & (df_add['Price']<400), 'Price'] = 2
df_add.loc[df_add['Price']>=400, 'Price'] = 3

df_add.describe()

df_add

df_add.Brand.unique()

"""Hanya mengambil data dengan brand ternama dan pemilik data terbanyak seperti samsung, oppo, vivo, xiaomi, dan realme untuk digabungkan dengan dataset awal"""

samsung = df_add.loc[df_add['Brand']=='samsung']
samsung = samsung.drop(columns=['Brand','Model Name','Model Image'])

oppo = df_add.loc[df_add['Brand']=='oppo']
oppo = oppo.drop(columns=['Brand','Model Name','Model Image'])

vivo = df_add.loc[df_add['Brand']=='vivo']
vivo = vivo.drop(columns=['Brand','Model Name','Model Image'])

xiaomi = df_add.loc[df_add['Brand']=='xiaomi']
xiaomi = xiaomi.drop(columns=['Brand','Model Name','Model Image'])

realme = df_add.loc[df_add['Brand']=='realme']
realme = realme.drop(columns=['Brand','Model Name','Model Image'])

print(len(df_new))
print(len(samsung))
print(len(oppo))
print(len(vivo))
print(len(xiaomi))
print(len(realme))

"""### Menggabungkan kedua dataset"""

df_final = pd.concat([df_new, samsung, vivo, oppo, xiaomi, realme], ignore_index=True, sort=False)

df_final

df_final.isnull().sum()

df_final.info()

df_final.describe()

"""Menghapus nilai yang tidak rasional pada variabel"""

df_final = df_final.loc[(df_final['Height(px)']!=1)]
df_final.shape

df_final.describe()

df_final

"""### Pengolahan Outliers dataframe final"""

sns.boxplot(x=df_final['Weight(g)'])

sns.boxplot(x=df_final['Width(px)'])

sns.boxplot(x=df_final['Height(px)'])

sns.boxplot(x=df_final['ROM(MB)'])

sns.boxplot(x=df_final['RAM(MB)'])

sns.boxplot(x=df_final['Battery Capacity(mAh)'])

# Proses drop outliers
Q1 = df_final.quantile(0.25)
Q3 = df_final.quantile(0.75)
IQR=Q3-Q1
df_final=df_final[~((df_final<(Q1-1.5*IQR))|(df_final>(Q3+1.5*IQR))).any(axis=1)]
 
# Cek ukuran dataset setelah outliers didrop
df_final.shape

"""Visualisasi dataframe final"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

df_final.hist(bins=50, figsize=(20,15))
plt.show()

list(df_final.columns.values[:6])

"""### Correlation Matrix

Melihat korelasi antar data pada keseluruhan dataset
"""

plt.figure(figsize=(10, 8))
correlation_matrix = df_final.corr().round(2)

sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, )
plt.title("Correlation Matrix untuk Fitur Numerik ", size=20)

"""## Data Preparation

### Train-Test Split

Membagi data menjadi train dan test set dengan ratio 80:20
"""

y = df_final['Price'] 

# Ambil fitur penting
li = list(df_final.columns.values[:6])
X = df_final[li]
# Split dataset menjadi train dan test
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=123)

print(X_test.shape)
print(X_train.shape)

X

y

"""## Modeling

Pada proyek ini digunakan model KNN, dikarenakan setelah ditelusuri, algoritma yang menghasilkan nilai akurasi terbaik adalah model KNN
"""

# Model KNN
knn = KNeighborsClassifier(n_neighbors=9)

knn.fit(X_train, y_train)

y_pred_knn = knn.predict(X_test)

a_KNN = metrics.accuracy_score(y_test, y_pred_knn)
print("Accuracy:",a_KNN)

"""Menampilkan metrik presisi, recall, dan juga f1 score dari hasil prediksi model KNN"""

print(classification_report(y_test, y_pred_knn))

"""## Data Testing

Melakukan data testing dengan menggunakan data inputan dari user dan menghasilkan nilai kelompok harga yang sesuai dengan harga di pasaran (USD) dan juga pada dataset

Nilai inputan dari user akan disimpan beserta dengan hasil prediksinya, yang kemudian akan digunakan pada model klasifikasi selanjutnya untuk mendapatkan model mobile phone yang sesuai dengan spesifikasi yang user mau.
"""

user_input = input()
prediction = knn.predict(np.array([[int(i) for i in user_input.split()]]))

user_input1 = np.array([int(i) for i in user_input.split()])

user_input1

prediction[0]